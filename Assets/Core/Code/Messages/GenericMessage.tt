<#@ template language="C#v3.5" #>
<#@ output extension=".cs" #>
<#
	int maxArgs = 5;
	
	Action<int> WriteTemplateArguments = (numArgs) =>
	{
		for(int i = 0; i< numArgs; i++)
		{
			Write("TArg" + i.ToString());
			if(i != numArgs-1)
			{
				Write(", ");
			}
		}
	};
	
	Action<int> WriteFunctionArguments = (numArgs) =>
	{
		for(int i = 0; i< numArgs; i++)
		{
			Write("TArg" + i.ToString() + " arg" + i.ToString());
			if(i != numArgs-1)
			{
				Write(", ");
			}
		}
	};
	
	Action<int> AssignArgs = (numArgs) =>
	{
		PushIndent("        ");
		for(int i = 0; i< numArgs; i++)
		{
			Write("m_arg" + i.ToString() + " = arg" + i.ToString() + ";\n");
		}
		ClearIndent();
	};
	
	Action<int> DeclareArgs = (numArgs) =>
	{
		PushIndent("    ");
		for(int i = 0; i< numArgs; i++)
		{
			Write("private TArg" + i.ToString() + " m_arg" + i.ToString() + ";\n");
		}
		ClearIndent();
	};
	
	Action<int> PassArgs = (numArgs) =>
	{
		for(int i = 0; i< numArgs; i++)
		{
			Write("m_arg" + i.ToString());
			if(i != numArgs-1)
			{
				Write(", ");
			}
		}
	};

	Action<int> PassGenericArgs = (numArgs) =>
	{
		for(int i = 0; i< numArgs; i++)
		{
			Write("(TArg"+i.ToString()+")args[" + i.ToString() + "]");
			if(i != numArgs-1)
			{
				Write(", ");
			}
		}
	};
#>
using System;
using System.Collections;
using System.Collections.Generic;

//CODE GENERATED BY T4
//DO NOT EDIT BY HAND
//EDIT THE .tt FILE, and use xamarin studio to regenerate
// add the tt file back to the project (unit removes it automatically)
//set custom tool to TextTemplatingFileGenerator see https://forums.xamarin.com/discussion/7573/run-t4-template-in-xamarin-studio

<#for(int i = 1; i <= maxArgs; i++){#>
public class Message<<#WriteTemplateArguments(i);#>> : IGenericMessage
{
	#region IGenericMessage implementation

	public IEnumerator WaitSendGeneric (object[] args)
	{
		return WaitSend(<#PassGenericArgs(i);#>);
	}

	public void AddHandlerGeneric (Func<object[], IEnumerator> handler)
	{
		if(!convertedGenericHandlers.ContainsKey(handler))
			convertedGenericHandlers[handler] = convertGenericHandler(handler);

		m_innerMessage.AddHandler(convertedGenericHandlers[handler]);
	}

	public void RemoveHandlerGeneric (Func<object[], IEnumerator> handler)
	{
		if(!convertedGenericHandlers.ContainsKey(handler))
			return;

		m_innerMessage.RemoveHandler(convertedGenericHandlers[handler]);
		convertedGenericHandlers.Remove(handler);
	}

	#endregion

	public delegate IEnumerator Handler(<#WriteFunctionArguments(i);#>);
	public delegate void HandlerAction(<#WriteFunctionArguments(i);#>);
	
	public IEnumerator WaitSend(<#WriteFunctionArguments(i);#>)
	{
<#AssignArgs(i);#>
		yield return new Routine(m_innerMessage.WaitSend());
	}

	public void AddAction(HandlerAction handler)
	{
		if(!convertedHandlerActions.ContainsKey(handler))
		{ 
			convertedHandlerActions[handler] = ConvertHandlerAction(handler);
		}

		m_innerMessage.AddHandler(convertedHandlerActions[handler]);
	}

	public void RemoveAction(HandlerAction handler)
	{
		if(!convertedHandlerActions.ContainsKey(handler))
		{ 
			return;
		}

		m_innerMessage.RemoveHandler(convertedHandlerActions[handler]);
		convertedHandlerActions.Remove(handler);
	}

	public void AddHandler(Handler handler)
	{
		if(!convertedHandlers.ContainsKey(handler))
		{ 
			convertedHandlers[handler] = ConvertHandler(handler);
		}

		m_innerMessage.AddHandler(convertedHandlers[handler]);
	}

	public void RemoveHandler(Handler handler)
	{
		if(!convertedHandlers.ContainsKey(handler))
		{ 
			return;
		}

		m_innerMessage.AddHandler(convertedHandlers[handler]);
		convertedHandlers.Remove(handler);
	}
	
	Func<IEnumerator> convertGenericHandler(Func<object[], IEnumerator> handler)
	{
		return () => wrapGenericHandler(handler);
	}

	IEnumerator wrapGenericHandler(Func<object[], IEnumerator> handler)
	{
		return handler(new Object[]{<#PassArgs(i);#> });
	}

	private Func<IEnumerator> ConvertHandler(Handler handler)
	{
		return () => handler(<#PassArgs(i);#>);
	}

	private Func<IEnumerator> ConvertHandlerAction(HandlerAction handler)
	{
		return () => WrapAction(handler);
	}

	private IEnumerator WrapAction(HandlerAction handler)
	{
		handler(<#PassArgs(i);#>);
		yield break;
	}

<#DeclareArgs(i);#>
	private readonly Message m_innerMessage = new Message();
	private static readonly Dictionary<Handler,Func<IEnumerator>> convertedHandlers = new Dictionary<Handler, Func<IEnumerator>>();
	private static readonly Dictionary<HandlerAction,Func<IEnumerator>> convertedHandlerActions = new Dictionary<HandlerAction, Func<IEnumerator>>();
	private Dictionary<Func<object[], IEnumerator>, Func<IEnumerator>> convertedGenericHandlers = new Dictionary<Func<object[], IEnumerator>, Func<IEnumerator>>();
}
<#}#>
