<#@ template language="C#v3.5" #>
<#@ output extension=".cs" #>
<#
	int maxArgs = 5;
	
	Action<int> WriteTemplateArguments = (numArgs) =>
	{
		for(int i = 0; i< numArgs; i++)
		{
			Write("TArg" + i.ToString());
			if(i != numArgs-1)
			{
				Write(", ");
			}
		}
	};
	
	Action<int> WriteFunctionArguments = (numArgs) =>
	{
		for(int i = 0; i< numArgs; i++)
		{
			Write("TArg" + i.ToString() + " arg" + i.ToString());
			if(i != numArgs-1)
			{
				Write(", ");
			}
		}
	};
	
	Action<int> AssignArgs = (numArgs) =>
	{
		PushIndent("        ");
		for(int i = 0; i< numArgs; i++)
		{
			Write("m_arg" + i.ToString() + " = arg" + i.ToString() + ";\n");
		}
		ClearIndent();
	};
	
	Action<int> DeclareArgs = (numArgs) =>
	{
		PushIndent("    ");
		for(int i = 0; i< numArgs; i++)
		{
			Write("private TArg" + i.ToString() + " m_arg" + i.ToString() + ";\n");
		}
		ClearIndent();
	};
	
	Action<int> PassArgs = (numArgs) =>
	{
		for(int i = 0; i< numArgs; i++)
		{
			Write("m_arg" + i.ToString());
			if(i != numArgs-1)
			{
				Write(", ");
			}
		}
	};
#>
using System;
using System.Collections;
using System.Collections.Generic;

//CODE GENERATED BY T4
//DO NOT EDIT BY HAND
//EDIT THE .tt FILE, and use monodevlop to regenerate
//see http://dan.s.wards.ws/how-to-execute-t4-text-templates-in-monodevelop/

<#for(int i = 1; i <= maxArgs; i++){#>
public class Message<<#WriteTemplateArguments(i);#>>
{
	public delegate IEnumerator Handler(<#WriteFunctionArguments(i);#>);
	
	public IEnumerator WaitSend(<#WriteFunctionArguments(i);#>)
	{
<#AssignArgs(i);#>
		yield return new Routine(m_innerMessage.WaitSend());
	}

	public void AddHandler(Handler handler)
	{
		if(!convertedHandlers.ContainsKey(handler))
		{ 
			convertedHandlers[handler] = ConvertHandler(handler);
		}

		m_innerMessage.AddHandler(convertedHandlers[handler]);
	}

	public void RemoveHandler(Handler handler)
	{
		if(!convertedHandlers.ContainsKey(handler))
		{ 
			return;
		}

		m_innerMessage.AddHandler(convertedHandlers[handler]);
		convertedHandlers.Remove(handler);
	}
	
	public IEnumerator WaitHandleMessage(Handler handler)
	{
		yield return new Routine(m_innerMessage.WaitHandleMessage(ConvertHandler(handler)));
	}
	
	public bool Idle
	{
		get
		{
			return m_innerMessage.Idle;
		}
	}
	
	public bool MessagePending
	{
		get
		{
			return m_innerMessage.MessagePending;
		}
	}
	
	private Func<IEnumerator> ConvertHandler(Handler handler)
	{
		return () => handler(<#PassArgs(i);#>);
	}

<#DeclareArgs(i);#>
	private readonly Message m_innerMessage = new Message();
	private static readonly Dictionary<Handler,Func<IEnumerator>> convertedHandlers = new Dictionary<Handler, Func<IEnumerator>>();
}
<#}#>
