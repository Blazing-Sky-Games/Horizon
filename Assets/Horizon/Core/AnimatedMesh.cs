//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;
using System.Linq;
using UnityEditor.Animations;
using System.IO;
using System.Threading;

#if UNITY_EDITOR
using UnityEditor;
#endif

namespace Horizon.Core
{
	[Serializable]
	public class AnimatedMesh
	{
		//TODO: function and etc to enable controling animation from script

		[SerializeField]
		// where do we find the prefab instance
		private GameObject Parent;
		
		[SerializeField]
		private GameObject m_mesh;

		public void setParent(GameObject Parent)
		{
			this.Parent = Parent;
#if UNITY_EDITOR
			RefreshMesh(); // here so it gets initilized
#endif
		}

#if UNITY_EDITOR
		const string UnitFolerPath = "Prefabs/Combat/Units/";
		const string ControlerFolderPath = "AnimationControllers/";

		public static List<AnimatedMesh> instances = new List<AnimatedMesh>();

		public AnimatedMesh()
		{
			instances.Add(this);
		}

		public GameObject mesh
		{
			get
			{
				return m_mesh;
			}
			set
			{
				if(value != null && PrefabUtility.GetPrefabType(value) != PrefabType.ModelPrefab)
				{
					Debug.LogWarning("animated mesh must reference a 3d model prefab");
				}
				else
				{
					GameObject oldMesh = m_mesh;
					m_mesh = value;

					if(oldMesh != value)
						RefreshMesh();
				}
			}
		}

		//set the prefab. refresh the animator controler. TODO: make it possible to manually refresh the animator controler
		public void RefreshMesh()
		{
			PrefabInstance meshParent = Parent.GetComponent<PrefabInstance>();

			//make sure the parent gamoeobject exists
			if(meshParent == null)
			{
				meshParent = Parent.AddComponent<PrefabInstance>();
			}

			meshParent.hideFlags = HideFlags.HideInInspector;
			meshParent.prefab = mesh;
			meshParent.OnValidate();

			if(mesh == null) return;

			string controllerPath = "Assets/" + ControlerFolderPath + mesh.name + ".controller";
			AnimatorController controller = null;
			if(mesh.GetComponent<Animator>().runtimeAnimatorController == null)
			{
				controller = AnimatorController.CreateAnimatorControllerAtPath (controllerPath);
				
				List<AnimationClip> clips;
				
				clips = AssetDatabase
					.LoadAllAssetRepresentationsAtPath(AssetDatabase.GetAssetPath(mesh))
						.Where(asset => asset.GetType() == typeof(AnimationClip))
						.Select(asset => asset as AnimationClip)
						.ToList();
				
				AnimationClip IdleAnim = clips.First(x => x.name == "Idle");
				
				clips.Remove(IdleAnim);
				
				if(Directory.Exists(Path.Combine(Application.dataPath,"Prefabs/Combat/Units")) == false)
				{
					AssetDatabase.CreateFolder("Assets/Prefabs/Combat","Units");
				}
				
				if(Directory.Exists(Path.Combine(Application.dataPath,"AnimationControllers")) == false)
				{
					AssetDatabase.CreateFolder("Assets","AnimationControllers");
				}
				
				AnimatorState IdleState = controller.AddMotion(IdleAnim,0);
				controller.layers[0].stateMachine.defaultState = IdleState;
				
				AnimatorStateTransition jumpToIdle = controller.layers[0].stateMachine.AddAnyStateTransition(IdleState);
				jumpToIdle.AddCondition(AnimatorConditionMode.If,0,"jumpTo" + IdleAnim.name);
				
				controller.AddParameter("jumpTo" + IdleAnim.name,AnimatorControllerParameterType.Trigger);
				
				foreach(var clip in clips)
				{
					AnimatorState state = controller.AddMotion(clip);
					
					AnimatorStateTransition jumpToState = controller.layers[0].stateMachine.AddAnyStateTransition(state);
					
					jumpToState.AddCondition(UnityEditor.Animations.AnimatorConditionMode.If,0,"jumpTo" + clip.name);
					
					controller.AddParameter("jumpTo" + clip.name,AnimatorControllerParameterType.Trigger);
					
					if(clip.isLooping == false)
					{
						AnimatorStateTransition backToIdle = state.AddTransition(IdleState);
						backToIdle.hasExitTime = true;
						backToIdle.exitTime = 1;
					}
				}

				mesh.GetComponent<Animator>().runtimeAnimatorController = controller;
			}
		}
#endif
	}
}

