//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Linq;
using Horizon.Core;
using Horizon.Core.WeakSubscription;
using System.Collections.Generic;
using UnityEngine;
using System.Collections.ObjectModel;
using Horizon.Core.ExtensionMethods;


namespace Horizon.Combat.Models
{
	//helper class that represents information about a gridline
	//a gridline is a line where two cells meat, or where a cell meets the edge of the grid
	public struct GridLine
	{
		public GridLine(Vector3 start,Vector3 end, Cell left, Cell right)
		{
			this.start = start;
			this.end = end;
			this.leftCell = left;
			this.rightCell = right;
		}
		
		// end points
		public readonly Vector3 start;
		public readonly Vector3 end;
		
		// the adjacent cells
		public readonly Cell leftCell;
		public readonly Cell rightCell;

		// all non null adjacent cells
		public IEnumerable<Cell> AdjacentCells
		{
			get
			{
				if(leftCell != null)
					yield return leftCell;

				if(rightCell != null)
					yield return rightCell;

				yield break;
			}
		}
	}

	public class Grid : ModelBase
	{
		//the parent of all the cells. cells are grouped like this to make the hierarchy easyer to look at
		private GameObject cellsParent;

		//returns a colum of cells
		// to get the cell at space (i,j) from a Grid named "grid", use
		// grid[i][j]
		public ReadOnlyCollection<Cell> this[int x]
		{
			get
			{
				return m_cells[x].AsReadOnly();
			}
		}

		//gets a cell from a grid point
		//to get a cell at point (i,j) from a Grid named "grid", use
		//grid[new gridpoint(i,j)]
		public Cell this[GridPoint point]
		{
			get
			{
				return m_cells[point.x][point.y];
			}
		}

		//iterate over all the gridlins
		public IEnumerable<GridLine> GridLines
		{
			get
			{
				//iterate over horizontal lines
				for(int j = 0; j <= Dimensions.y; j += 1)
				{
					for(int i = 0; i < Dimensions.x; i += 1)
					{
						// the grid lins have there y pos slighly elavated so they show above the physcial grid
						Vector3 start = transform.rotation * new Vector3( transform.position.x + i, transform.position.y + 0.01f, transform.position.z + j );
						Vector3 end = transform.rotation * new Vector3( transform.position.x + (i+1), transform.position.y + 0.01f, transform.position.z + j );

						if(j == 0) // bottom edge
						{
							yield return new GridLine(start,end,this[i][j],null);
						}
						else if(j == Dimensions.y) // top edge
						{
							yield return new GridLine(start,end,null,this[i][j-1]);
						}
						else
						{
							yield return new GridLine(start,end,this[i][j],this[i][j-1]);
						}
					}
					
				}
				
				//iterate over vertical lines
				for(int i = 0; i <= Dimensions.x; i += 1)
				{
					for(int j = 0; j < Dimensions.y; j += 1)
					{
						// the grid lins have there y pos slighly elavated so they show above the physcial grid
						Vector3 start = transform.rotation * new Vector3( transform.position.x + i, transform.position.y + 0.01f, transform.position.z + j );
						Vector3 end = transform.rotation * new Vector3( transform.position.x + i, transform.position.y + 0.01f, transform.position.z + (j+1) );

						if(i == 0) //left most edge
						{
							yield return new GridLine(start,end,this[i][j],null);
						}
						else if(i == Dimensions.x)//right most edge
						{
							yield return new GridLine(start,end,null,this[i-1][j]);
						}
						else
						{
							yield return new GridLine(start,end,this[i][j],this[i-1][j]);
						}
					}
				}
			}
		}

		// x and y Dimensions
		public GridPoint Dimensions
		{
			get
			{
				return m_dimensionsSerilized;
			}
			set
			{
				if(value.x < 0) value = new GridPoint(0,value.y);
				if(value.y < 0) value = new GridPoint(value.x,0);
				if(SetPropertyFeild(ref m_dimensionsSerilized,value,()=> Dimensions))
				{
					//if the dim changed, we need to resize
					resizeGrid();
				}
			}
		}

		//orginal cell
		//all cells in the grid are copys of this cell
		public GameObject CellPrefab
		{
			get
			{
				return m_cellPrefabSerilized;
			}
			set
			{
				if(value == null || value.GetComponent<Cell>() == null)
				{
					Debug.LogError("gameobject must have the cell script attached to be assigned to the grid's cell prefab");
				}
				else
				{
					if(SetPropertyFeild(ref m_cellPrefabSerilized,value,() => CellPrefab))
					{
						GridPoint oldDim = Dimensions;
						Dimensions = new GridPoint(0,0); // deleat all the old cells
						Dimensions = oldDim; // recreate the grid
					}
				}
			}
		}

		protected override void Init ()
		{
			base.Init();

			//create the gameobject to parent cells to
			Transform cellsParentTran = transform.FindChild("cells");
			if(cellsParentTran == null)
			{
				cellsParent = new GameObject("cells");
				cellsParent.transform.parent = transform;
				cellsParent.transform.localPosition = Vector3.zero;
				cellsParent.transform.localRotation = Quaternion.identity;
				cellsParent.transform.localScale = new Vector3(1,1,1);
			}
			else
			{
				cellsParent = cellsParentTran.gameObject;
			}

			//resize the grid if needed
			if(m_cells.Count != Dimensions.x || (m_cells.Count == 0 ? 0 : m_cells[0].Count) != Dimensions.y)
			{
				resizeGrid();
			}
		}

		private Cell NewCellAt (int x, int y)
		{
			GameObject newCell = Instantiate (CellPrefab);
			newCell.transform.parent = cellsParent.transform;
			Cell cellComponent = newCell.GetComponent<Cell> ();
			cellComponent.grid = this;
			cellComponent.GridPosition = new GridPoint (x, y);
			return cellComponent;
		}

		//long tedious code to handle the dims changing
		private void resizeGrid()
		{
			if(CellPrefab == null)
			{
				Debug.LogError("cannot resize grid, cell prefab is null");
				return;
			}

			if(Dimensions.x == 0)
			{
				foreach(List<Cell> cells in m_cells)
				{
					foreach(Cell cell in cells)
					{
						if(cell != null)
						{
							GameObject todestroy = cell.gameObject;
							this.DisposeAndDestroy(cell);
							DestroyImmediate(todestroy);
						}
					}

					cells.Clear();
				}

				m_cells.Clear();
			}
			else
			{
				if(m_cells.Count < Dimensions.x)
				{
					for(int i = m_cells.Count; i < Dimensions.x; i++)
					{
						CellList cells = new CellList();
						
						for(int j = 0; j<Dimensions.y; j++)
						{
							Cell cellComponent = NewCellAt (i, j);
							cells.Add(cellComponent);
						}
						
						m_cells.Add(cells);
					}
				}
				else if(m_cells.Count > Dimensions.x)
				{
					for(int i = Dimensions.x; i < m_cells.Count; i++)
					{
						List<Cell> cells = m_cells[i];
						foreach(Cell cell in cells)
						{
							if(cell!= null)
							{
								GameObject todestroy = cell.gameObject;
								this.DisposeAndDestroy(cell);
								DestroyImmediate(todestroy);
							}
						}
						
						cells.Clear();
					}
					
					m_cells.RemoveRange(Dimensions.x, m_cells.Count - Dimensions.x);
				}

				if(Dimensions.y == 0)
				{
					foreach(List<Cell> cells in m_cells)
					{
						foreach(Cell cell in cells)
						{
							if(cell != null)
							{
								GameObject todestroy = cell.gameObject;
								this.DisposeAndDestroy(cell);
								DestroyImmediate(todestroy);
							}
						}
						
						cells.Clear();
					}
				}
				else if(m_cells[0].Count < Dimensions.y)
				{
					for(int i = 0; i < m_cells.Count; i++)
					{
						for(int j = m_cells[i].Count; j < Dimensions.y ; j++)
						{
							Cell cellComponent = NewCellAt (i, j);
							m_cells[i].Add(cellComponent);
						}
					}
				}
				else if(m_cells[0].Count > Dimensions.y)
				{
					foreach(List<Cell> cells in m_cells)
					{
						for(int j = Dimensions.y; j < cells.Count; j++)
						{
							if(cells[j] != null)
							{
								GameObject todestroy = cells[j].gameObject;
								this.DisposeAndDestroy(cells[j]);
								DestroyImmediate(todestroy);
							}
						}

						cells.RemoveRange(Dimensions.y, cells.Count - Dimensions.y);
					}
				}
			}
		}

		//unity cannot serilize nested lists, so we creat a wrapper class to fix that
		[Serializable]
		private class CellList // cell list is bassically just List<Cell>
		{
			public List<Cell> cells = new List<Cell>();

			public Cell this[int index]
			{
				get
				{
					return cells[index];
				}
				set
				{
					cells[index] = value;
				}
			}

			static public implicit operator List<Cell>(CellList other)
			{
				return other.cells;
			}

			public void Add(Cell c)
			{
				cells.Add (c);
			}

			public int Count
			{
				get
				{
					return cells.Count;
				}
			}

			public ReadOnlyCollection<Cell> AsReadOnly()
			{
				return cells.AsReadOnly();
			}
		}

		[SerializeField]
		private List<CellList> m_cells = new List<CellList>();

		[SerializeField]
		private GridPoint m_dimensionsSerilized;

		[SerializeField]
		private GameObject m_cellPrefabSerilized;
	}
}

