//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Linq;
using Horizon.Core;
using Horizon.Core.WeakSubscription;
using System.Collections.Generic;
using UnityEngine;
using System.Collections.ObjectModel;
using Horizon.Core.ExtensionMethods;


namespace Horizon.Combat.Models
{
	public class Grid : ModelBase
	{
		public int CellCount
		{
			get
			{
				return m_cells.Count == 0 ? 0 : m_cells.Count * m_cells[0].Count;
			}
		}

		public ReadOnlyCollection<Cell> this[int x]
		{
			get
			{
				return m_cells[x].AsReadOnly();
			}
		}

		public Cell this[GridPoint point]
		{
			get
			{
				return m_cells[point.x][point.y];
			}
		}

		public GridPoint Dimensions
		{
			get
			{
				return m_dimensionsSerilized;
			}
			set
			{
				if(value.x < 0) value = new GridPoint(0,value.y);
				if(value.y < 0) value = new GridPoint(value.x,0);
				if(SetPropertyFeild(ref m_dimensionsSerilized,value,()=> Dimensions))
				{
					resizeGrid();
				}
			}
		}

		public GameObject CellPrefab
		{
			get
			{
				return m_cellPrefabSerilized;
			}
			set
			{
				if(value == null || value.GetComponent<Cell>() == null)
				{
					Debug.LogError("gameobject must have the cell script attached to be assigned to the grids cell prefab");
				}
				else
				{
					if(SetPropertyFeild(ref m_cellPrefabSerilized,value,() => CellPrefab))
					{
						GridPoint oldDim = Dimensions;
						Dimensions = new GridPoint(0,0);
						Dimensions = oldDim;
					}
				}
			}
		}

		public float CellSize
		{
			get
			{
				return m_cellSizeSerilized;
			}
			set
			{
				if(SetPropertyFeild(ref m_cellSizeSerilized, value, () => CellSize))
				{
					resizeCells();
				}
			}
		}

		protected override void Init ()
		{
			base.Init();

			if(m_cells.Count != Dimensions.x || (m_cells.Count == 0 ? 0 : m_cells[0].Count) != Dimensions.y)
			{
				resizeGrid();
			}

			if(CellCount != 0 && this[new GridPoint()].CellSize != CellSize)
			{
				resizeCells();
			}
		}

		private void resizeGrid()
		{
			if(CellPrefab == null)
			{
				Debug.LogError("cannot resize grid, cell prefab is null");
				return;
			}

			if(Dimensions.x == 0)
			{
				foreach(List<Cell> cells in m_cells)
				{
					foreach(Cell cell in cells)
					{
						if(cell != null)
						{
							GameObject todestroy = cell.gameObject;
							this.DisposeAndDestroy(cell);
							DestroyImmediate(todestroy);
						}
					}

					cells.Clear();
				}

				m_cells.Clear();
			}
			else
			{
				if(m_cells.Count < Dimensions.x)
				{
					for(int i = m_cells.Count; i < Dimensions.x; i++)
					{
						CellList cells = new CellList();
						
						for(int j = 0; j<Dimensions.y; j++)
						{
							GameObject newCell = Instantiate(CellPrefab);
							newCell.name = "(" + i + "," + j + ")";
							newCell.transform.parent = this.transform;
							newCell.transform.localPosition = new Vector3(i,0,j) * CellSize + new Vector3(CellSize/2,0,CellSize/2);
							Cell cellComponent = newCell.GetComponent<Cell>();
							cellComponent.CellSize = CellSize;
							cells.Add(cellComponent);
						}
						
						m_cells.Add(cells);
					}
				}
				else if(m_cells.Count > Dimensions.x)
				{
					for(int i = Dimensions.x; i < m_cells.Count; i++)
					{
						List<Cell> cells = m_cells[i];
						foreach(Cell cell in cells)
						{
							if(cell!= null)
							{
								GameObject todestroy = cell.gameObject;
								this.DisposeAndDestroy(cell);
								DestroyImmediate(todestroy);
							}
						}
						
						cells.Clear();
					}
					
					m_cells.RemoveRange(Dimensions.x, m_cells.Count - Dimensions.x);
				}

				if(Dimensions.y == 0)
				{
					foreach(List<Cell> cells in m_cells)
					{
						foreach(Cell cell in cells)
						{
							if(cell != null)
							{
								GameObject todestroy = cell.gameObject;
								this.DisposeAndDestroy(cell);
								DestroyImmediate(todestroy);
							}
						}
						
						cells.Clear();
					}
				}
				else if(m_cells[0].Count < Dimensions.y)
				{
					for(int i = 0; i < m_cells.Count; i++)
					{
						for(int j = m_cells[i].Count; j < Dimensions.y ; j++)
						{
							GameObject newCell = Instantiate(CellPrefab);
							newCell.name = "(" + i + "," + j + ")";
							newCell.transform.parent = this.transform;
							newCell.transform.localPosition = new Vector3(i,0,j) * CellSize + new Vector3(CellSize/2,0,CellSize/2);
							Cell cellComponent = newCell.GetComponent<Cell>();
							cellComponent.CellSize = CellSize;
							m_cells[i].Add(cellComponent);
						}
					}
				}
				else if(m_cells[0].Count > Dimensions.y)
				{
					foreach(List<Cell> cells in m_cells)
					{
						for(int j = Dimensions.y; j < cells.Count; j++)
						{
							if(cells[j] != null)
							{
								GameObject todestroy = cells[j].gameObject;
								this.DisposeAndDestroy(cells[j]);
								DestroyImmediate(todestroy);
							}
						}

						cells.RemoveRange(Dimensions.y, cells.Count - Dimensions.y);
					}
				}
			}
		}

		private void resizeCells()
		{
			for(int i = 0; i < Dimensions.x; i++)
			{
				for(int j = 0; j < Dimensions.y; j++)
				{
					this[i][j].transform.localPosition = new Vector3(i,0,j) * CellSize + new Vector3(CellSize/2,0,CellSize/2);
					this[i][j].CellSize = CellSize;
				}
			}
		}

		//unity cannot serilize nested lists, so we creat a wrapper class to fix that
		[Serializable]
		private class CellList
		{
			public List<Cell> cells = new List<Cell>();

			public Cell this[int index]
			{
				get
				{
					return cells[index];
				}
				set
				{
					cells[index] = value;
				}
			}

			static public implicit operator List<Cell>(CellList other)
			{
				return other.cells;
			}

			public void Add(Cell c)
			{
				cells.Add (c);
			}

			public int Count
			{
				get
				{
					return cells.Count;
				}
			}

			public ReadOnlyCollection<Cell> AsReadOnly()
			{
				return cells.AsReadOnly();
			}
		}

		[SerializeField]
		private List<CellList> m_cells = new List<CellList>();

		[SerializeField]
		private GridPoint m_dimensionsSerilized;

		[SerializeField]
		private GameObject m_cellPrefabSerilized;

		[SerializeField]
		private float m_cellSizeSerilized = 1;
	}
}

